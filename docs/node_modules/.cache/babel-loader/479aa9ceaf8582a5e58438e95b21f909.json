{"ast":null,"code":"// export const mergeSort = array => {\n//     if(array.length === 1){\n//         return array;\n//     }\n//     const midIndex = Math.floor(array.length / 2);\n//     const firstHalf = mergeSort(array.slice(0, midIndex));\n//     const secondHalf = mergeSort(array.slice(midIndex));\n//     const sortedArray = [];\n//     let i = 0;\n//     let j = 0;\n//     while(i < firstHalf.length && j < secondHalf.length){\n//         if(firstHalf[i] < secondHalf[j]){\n//             sortedArray.push(firstHalf[i++]);\n//         }else{\n//             sortedArray.push(secondHalf[j++]);\n//         }\n//     }\n//     while(i < firstHalf.length){\n//         sortedArray.push(firstHalf[i++]);\n//     }\n//     while(j < secondHalf.length){\n//         sortedArray.push(secondHalf[j++]);\n//     }\n//     return sortedArray;\n// };\nexport function getBubbleSortAnimations(array){var animations=[];var n=array.length;for(var i=0;i<n-1;i++){for(var j=0;j<n-i-1;j++){animations.push([j,j+1,false,false]);animations.push([j,j+1,false,true]);if(array[j]>array[j+1]){animations.push([j,j+1,true,true]);animations.push([j,j+1,true,true]);swap(array,j,j+1);}}}return animations;}export function getHeapSortAnimations(array){var animations=[];if(array.length<=1){return array;}getHeapSortHelper(array,animations);console.log(array);return animations;}function getHeapSortHelper(mainArray,animations){var n=mainArray.length;//Build Heap\nfor(var i=Math.floor(n/2)-1;i>=0;i--){heapify(mainArray,n,i,animations);}// One by one extract an element from heap \nfor(var j=n-1;j>=0;j--){animations.push([0,mainArray[j],true,true]);animations.push([j,mainArray[0],true,true]);swap(mainArray,0,j);heapify(mainArray,j,0,animations);}}function heapify(mainArray,n,i,animations){var largest=i;// Initialize largest as root \nvar l=2*i+1;// left = 2*i + 1 \nvar r=2*i+2;// right = 2*i + 2 \nif(l<mainArray.length){animations.push([largest,l,false,false]);animations.push([largest,l,false,true]);}// If left child is larger than root \nif(l<n&&mainArray[l]>mainArray[largest]){largest=l;}if(r<mainArray.length){animations.push([largest,r,false,false]);animations.push([largest,r,false,true]);}// If right child is larger than largest so far \nif(r<n&&mainArray[r]>mainArray[largest]){largest=r;}// If largest is not root \nif(largest!=i){animations.push([i,mainArray[largest],true,true]);animations.push([largest,mainArray[i],true,true]);swap(mainArray,i,largest);// Recursively heapify the affected sub-tree \nheapify(mainArray,n,largest,animations);}}export function getQuickSortAnimations(array){var animations=[];if(array.length<=1){return array;}getQuickSortHelper(array,0,array.length-1,animations);console.log(array);return animations;}function getQuickSortHelper(mainArray,low,high,animations){if(low<high){var pi=partition(mainArray,low,high,animations);console.log(pi);getQuickSortHelper(mainArray,low,pi-1,animations);getQuickSortHelper(mainArray,pi+1,high,animations);}}function partition(mainArray,low,high,animations){var pivot=mainArray[high];var i=low-1;var j=low;for(j=low;j<high;j++){animations.push([j,high,false,false]);animations.push([j,high,false,true]);if(mainArray[j]<pivot){i++;animations.push([i,mainArray[j],true,true]);animations.push([j,mainArray[i],true,true]);swap(mainArray,i,j);}}animations.push([i+1,mainArray[high],true,true]);animations.push([high,mainArray[i+1],true,true]);swap(mainArray,i+1,high);return i+1;}function swap(array,x,y){// animations.push([x, high, false, false]);\n// animations.push([x, high, false, true]);\n// animations.push([x, array[y], true, true]);\n// animations.push([y, array[x], true, true]);\nvar temp=array[x];array[x]=array[y];array[y]=temp;}export function getMergeSortAnimations(array){var animations=[];if(array.length<=1){return array;}var auxiliaryArray=array.slice();mergeSortHelper(array,0,array.length-1,auxiliaryArray,animations);return animations;}function mergeSortHelper(mainArray,startIdx,endIdx,auxiliaryArray,animations){if(startIdx===endIdx){return;}var middleIdx=Math.floor((startIdx+endIdx)/2);mergeSortHelper(auxiliaryArray,startIdx,middleIdx,mainArray,animations);mergeSortHelper(auxiliaryArray,middleIdx+1,endIdx,mainArray,animations);doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations);}function doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations){var k=startIdx;var i=startIdx;var j=middleIdx+1;while(i<=middleIdx&&j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,j]);if(auxiliaryArray[i]<=auxiliaryArray[j]){// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k]=auxiliaryArray[i];k++;i++;}else{// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k]=auxiliaryArray[j];k++;j++;}}while(i<=middleIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,i]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,i]);// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k]=auxiliaryArray[i];k++;i++;}while(j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([j,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([j,j]);// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k]=auxiliaryArray[j];k++;j++;}}","map":{"version":3,"sources":["/Users/owner/myProject/Sorting-Visualizer/docs/src/SortingAlgorithms.js"],"names":["getBubbleSortAnimations","array","animations","n","length","i","j","push","swap","getHeapSortAnimations","getHeapSortHelper","console","log","mainArray","Math","floor","heapify","largest","l","r","getQuickSortAnimations","getQuickSortHelper","low","high","pi","partition","pivot","x","y","temp","getMergeSortAnimations","auxiliaryArray","slice","mergeSortHelper","startIdx","endIdx","middleIdx","doMerge","k"],"mappings":"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","sourcesContent":["// export const mergeSort = array => {\n//     if(array.length === 1){\n//         return array;\n//     }\n\n//     const midIndex = Math.floor(array.length / 2);\n//     const firstHalf = mergeSort(array.slice(0, midIndex));\n//     const secondHalf = mergeSort(array.slice(midIndex));\n//     const sortedArray = [];\n\n//     let i = 0;\n//     let j = 0;\n\n//     while(i < firstHalf.length && j < secondHalf.length){\n//         if(firstHalf[i] < secondHalf[j]){\n//             sortedArray.push(firstHalf[i++]);\n//         }else{\n//             sortedArray.push(secondHalf[j++]);\n//         }\n//     }\n\n//     while(i < firstHalf.length){\n//         sortedArray.push(firstHalf[i++]);\n//     }\n//     while(j < secondHalf.length){\n//         sortedArray.push(secondHalf[j++]);\n//     }\n//     return sortedArray;\n// };\n\nexport function getBubbleSortAnimations(array){\n    let animations = [];\n    let n = array.length; \n    for (let i = 0; i < n-1; i++){ \n        for (let j = 0; j < n-i-1; j++){\n            animations.push([j, j+1, false, false]);\n            animations.push([j, j+1, false, true]);\n            if (array[j] > array[j+1]) \n            { \n                animations.push([j, j+1, true, true]);\n                animations.push([j, j+1, true, true]);\n                swap(array, j, j + 1);\n            } \n        }\n    }\n    return animations;      \n}\n\nexport function getHeapSortAnimations(array){\n    let animations = [];\n    if (array.length <= 1){\n        return array;\n    } \n    getHeapSortHelper(array,animations);\n    console.log(array);\n    return animations;\n}\n\nfunction getHeapSortHelper(mainArray, animations){\n    let n = mainArray.length;\n    //Build Heap\n    for(let i = Math.floor(n / 2) -1; i >= 0; i--){\n        heapify(mainArray, n, i, animations);\n    }\n    // One by one extract an element from heap \n    for(let j = n-1; j >= 0; j--){\n        animations.push([0, mainArray[j], true, true]);\n        animations.push([j, mainArray[0], true, true]);\n        swap(mainArray, 0, j );\n        heapify(mainArray, j,  0, animations);\n    }\n}\n\nfunction heapify(mainArray, n, i, animations){\n    let largest = i; // Initialize largest as root \n    let l = 2*i + 1; // left = 2*i + 1 \n    let r = 2*i + 2; // right = 2*i + 2 \n\n    if(l < mainArray.length){\n        animations.push([largest, l, false, false]);\n        animations.push([largest, l, false, true]);\n    }\n    // If left child is larger than root \n    if (l < n && mainArray[l] > mainArray[largest]) {\n        largest = l; \n    }\n\n    if(r < mainArray.length){   \n        animations.push([largest, r, false, false]);\n        animations.push([largest, r, false, true]);\n    }\n    // If right child is larger than largest so far \n    if (r < n && mainArray[r] > mainArray[largest]){\n        largest = r; \n    }   \n    // If largest is not root \n    if (largest != i){ \n        animations.push([i, mainArray[largest], true, true]);\n        animations.push([largest, mainArray[i], true, true]);\n        swap(mainArray, i, largest);\n        // Recursively heapify the affected sub-tree \n        heapify(mainArray, n, largest, animations); \n    } \n}\n\nexport function getQuickSortAnimations(array){\n    let animations = [];\n    if (array.length <= 1){\n        return array;\n    } \n    getQuickSortHelper(array, 0, array.length - 1, animations);\n    console.log(array);\n    return animations;\n}\n\nfunction getQuickSortHelper(mainArray, low, high, animations){\n    if(low < high){\n        let pi = partition(mainArray, low, high, animations);\n        console.log(pi);\n        getQuickSortHelper(mainArray, low, pi-1, animations); \n        getQuickSortHelper(mainArray, pi+1, high, animations); \n    }\n}\n\nfunction partition(mainArray, low, high, animations){\n    let pivot = mainArray[high];\n    let i = low - 1;\n    let j = low;\n\n    for(j = low; j < high; j ++){\n        animations.push([j,high, false, false]);\n        animations.push([j,high, false, true]);\n        if(mainArray[j] < pivot){\n            i++;\n            animations.push([i, mainArray[j], true, true]);\n            animations.push([j, mainArray[i], true, true]);\n            swap(mainArray, i, j)\n        }\n    }\n    animations.push([i+1, mainArray[high], true, true]);\n    animations.push([high, mainArray[i+1], true, true]);\n    swap(mainArray, i+1, high)\n\n    return i + 1;\n}\n\nfunction swap(array, x , y){\n    // animations.push([x, high, false, false]);\n    // animations.push([x, high, false, true]);\n    // animations.push([x, array[y], true, true]);\n    // animations.push([y, array[x], true, true]);\n    let temp = array[x];\n    array[x] = array[y];\n    array[y] = temp;\n}\n\nexport function getMergeSortAnimations(array) {\n    let animations = [];\n    if (array.length <= 1){\n        return array;\n    } \n    const auxiliaryArray = array.slice();\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n    return animations;\n}\n\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n    if (startIdx === endIdx){\n        return;\n    }\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\n    let k = startIdx;\n    let i = startIdx;\n    let j = middleIdx + 1;\n\n    while (i <= middleIdx && j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, j]);\n\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n            // We overwrite the value at index k in the original array with the\n            // value at index i in the auxiliary array.\n            animations.push([k, auxiliaryArray[i]]);\n            mainArray[k] = auxiliaryArray[i];\n            k++;\n            i++;\n        } else {\n            // We overwrite the value at index k in the original array with the\n            // value at index j in the auxiliary array.\n            animations.push([k, auxiliaryArray[j]]);\n            mainArray[k] = auxiliaryArray[j];\n            k++;\n            j++;\n        }\n    }\n    while (i <= middleIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, i]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, i]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, auxiliaryArray[i]]);\n        mainArray[k] = auxiliaryArray[i];\n        k++;\n        i++;\n    }\n    while (j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([j, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([j, j]);\n        // We overwrite the value at index k in the original array with the\n        // value at index j in the auxiliary array.\n        animations.push([k, auxiliaryArray[j]]);\n        mainArray[k] = auxiliaryArray[j];\n        k++;\n        j++;\n    }\n}"]},"metadata":{},"sourceType":"module"}